{
    "sourceFile": "src/core/features/login/services/login-helper.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1693559438901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1693685288030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -43,9 +43,9 @@\n import { CoreSettingsHelper } from '@features/settings/services/settings-helper';\n \n const PASSWORD_RESETS_CONFIG_KEY = 'password-resets';\n \n-export const GET_STARTED_URL = 'https://swiftlearn.co.uk';\n+export const GET_STARTED_URL = 'https://swift1.co.uk';\n \n /**\n  * Helper provider that provides some common features regarding authentication.\n  */\n"
                }
            ],
            "date": 1693559438901,
            "name": "Commit-0",
            "content": "// (C) Copyright 2015 Moodle Pty Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Injectable, SecurityContext } from '@angular/core';\nimport { Params } from '@angular/router';\nimport { Md5 } from 'ts-md5/dist/md5';\n\nimport { CoreApp, CoreStoreConfig } from '@services/app';\nimport { CoreConfig } from '@services/config';\nimport { CoreEvents, CoreEventSessionExpiredData, CoreEventSiteData } from '@singletons/events';\nimport { CoreSites, CoreLoginSiteInfo, CoreSiteBasicInfo } from '@services/sites';\nimport { CoreWS, CoreWSExternalWarning } from '@services/ws';\nimport { CoreDomUtils } from '@services/utils/dom';\nimport { CoreTextUtils } from '@services/utils/text';\nimport { CoreUrlParams, CoreUrlUtils } from '@services/utils/url';\nimport { CoreUtils } from '@services/utils/utils';\nimport { CoreConstants } from '@/core/constants';\nimport { CoreSite, CoreSiteIdentityProvider, CoreSitePublicConfigResponse, CoreSiteQRCodeType } from '@classes/site';\nimport { CoreError } from '@classes/errors/error';\nimport { CoreWSError } from '@classes/errors/wserror';\nimport { DomSanitizer, makeSingleton, Translate } from '@singletons';\nimport { CoreLogger } from '@singletons/logger';\nimport { CoreUrl } from '@singletons/url';\nimport { CoreNavigator, CoreRedirectPayload } from '@services/navigator';\nimport { CoreCanceledError } from '@classes/errors/cancelederror';\nimport { CoreCustomURLSchemes } from '@services/urlschemes';\nimport { CorePushNotifications } from '@features/pushnotifications/services/pushnotifications';\nimport { CorePath } from '@singletons/path';\nimport { CorePromisedValue } from '@classes/promised-value';\nimport { SafeHtml } from '@angular/platform-browser';\nimport { CoreLoginError } from '@classes/errors/loginerror';\nimport { CoreSettingsHelper } from '@features/settings/services/settings-helper';\n\nconst PASSWORD_RESETS_CONFIG_KEY = 'password-resets';\n\nexport const GET_STARTED_URL = 'https://swiftlearn.co.uk';\n\n/**\n * Helper provider that provides some common features regarding authentication.\n */\n@Injectable({ providedIn: 'root' })\nexport class CoreLoginHelperProvider {\n\n    /**\n     * @deprecated since 3.9.5.\n     */\n    static readonly OPEN_COURSE = 'open_course';\n\n    static readonly ONBOARDING_DONE = 'onboarding_done';\n    static readonly FAQ_URL_IMAGE_HTML = '<img src=\"assets/img/login/faq_url.png\" role=\"presentation\" alt=\"\">';\n    static readonly FAQ_QRCODE_IMAGE_HTML = '<img src=\"assets/img/login/faq_qrcode.png\" role=\"presentation\" alt=\"\">';\n\n    protected logger: CoreLogger;\n    protected sessionExpiredCheckingSite: Record<string, boolean> = {};\n    protected isOpenEditAlertShown = false;\n    protected waitingForBrowser?: CorePromisedValue<void>;\n\n    constructor() {\n        this.logger = CoreLogger.getInstance('CoreLoginHelper');\n    }\n\n    /**\n     * Initialize service.\n     */\n    async initialize(): Promise<void> {\n        this.cleanUpPasswordResets();\n    }\n\n    /**\n     * Accept site policy.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved if success, rejected if failure.\n     */\n    async acceptSitePolicy(siteId?: string): Promise<void> {\n        const site = await CoreSites.getSite(siteId);\n\n        const result = await site.write<AgreeSitePolicyResult>('core_user_agree_site_policy', {});\n\n        if (result.status) {\n            return;\n        }\n\n        if (!result.warnings?.length) {\n            throw new CoreError('Cannot agree site policy');\n        }\n\n        // Check if there is a warning 'alreadyagreed'.\n        const found = result.warnings.some((warning) => warning.warningcode === 'alreadyagreed');\n        if (found) {\n            // Policy already agreed, treat it as a success.\n            return;\n        }\n\n        // Another warning, reject.\n        throw new CoreWSError(result.warnings[0]);\n\n    }\n\n    /**\n     * Check if a site allows requesting a password reset through the app.\n     *\n     * @param siteUrl URL of the site.\n     * @returns Promise resolved with boolean: whether can be done through the app.\n     */\n    async canRequestPasswordReset(siteUrl: string): Promise<boolean> {\n        try {\n            await this.requestPasswordReset(siteUrl);\n\n            return true;\n        } catch (error) {\n            return error.available == 1 || (error.errorcode && error.errorcode != 'invalidrecord');\n        }\n    }\n\n    /**\n     * Function called when an SSO InAppBrowser is closed or the app is resumed. Check if user needs to be logged out.\n     */\n    checkLogout(): void {\n        const currentSite = CoreSites.getCurrentSite();\n\n        if (\n            !CoreApp.isSSOAuthenticationOngoing() &&\n            currentSite?.isLoggedOut() &&\n            CoreNavigator.isCurrent('/login/reconnect')\n        ) {\n            // User must reauthenticate but he closed the InAppBrowser without doing so, logout him.\n            CoreSites.logout();\n        }\n    }\n\n    /**\n     * Show a confirm modal if needed and open a browser to perform SSO login.\n     *\n     * @param siteUrl URL of the site where the SSO login will be performed.\n     * @param typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.\n     * @param service The service to use. If not defined, core service will be used.\n     * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n     * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n     * @returns Promise resolved when done or if user cancelled.\n     */\n    async confirmAndOpenBrowserForSSOLogin(\n        siteUrl: string,\n        typeOfLogin: number,\n        service?: string,\n        launchUrl?: string,\n        redirectData?: CoreRedirectPayload,\n    ): Promise<void> {\n        // Show confirm only if it's needed. Treat \"false\" (string) as false to prevent typing errors.\n        const showConfirmation = this.shouldShowSSOConfirm(typeOfLogin);\n\n        if (showConfirmation) {\n            try {\n                await CoreDomUtils.showConfirm(Translate.instant('core.login.logininsiterequired'));\n            } catch {\n                // User canceled, stop.\n                return;\n            }\n        }\n\n        this.openBrowserForSSOLogin(siteUrl, typeOfLogin, service, launchUrl, redirectData);\n    }\n\n    /**\n     * Helper function to act when the forgotten password is clicked.\n     *\n     * @param siteUrl Site URL.\n     * @param username Username.\n     * @param siteConfig Site config.\n     */\n    async forgottenPasswordClicked(siteUrl: string, username: string, siteConfig?: CoreSitePublicConfigResponse): Promise<void> {\n        if (siteConfig && siteConfig.forgottenpasswordurl) {\n            // URL set, open it.\n            CoreUtils.openInApp(siteConfig.forgottenpasswordurl);\n\n            return;\n        }\n\n        // Check if password reset can be done through the app.\n        const modal = await CoreDomUtils.showModalLoading();\n\n        try {\n            const canReset = await this.canRequestPasswordReset(siteUrl);\n\n            if (canReset) {\n                await CoreNavigator.navigate('/login/forgottenpassword', {\n                    params: {\n                        siteUrl,\n                        siteConfig,\n                        username,\n                    },\n                });\n            } else {\n                this.openForgottenPassword(siteUrl);\n            }\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Format profile fields, filtering the ones that shouldn't be shown on signup and classifying them in categories.\n     *\n     * @param profileFields Profile fields to format.\n     * @returns Categories with the fields to show in each one.\n     */\n    formatProfileFieldsForSignup(profileFields?: AuthEmailSignupProfileField[]): AuthEmailSignupProfileFieldsCategory[] {\n        if (!profileFields) {\n            return [];\n        }\n\n        const categories: Record<number, AuthEmailSignupProfileFieldsCategory> = {};\n\n        profileFields.forEach((field) => {\n            if (!field.signup || !field.categoryid) {\n                // Not a signup field, ignore it.\n                return;\n            }\n\n            if (!categories[field.categoryid]) {\n                categories[field.categoryid] = {\n                    id: field.categoryid,\n                    name: field.categoryname || '',\n                    fields: [],\n                };\n            }\n\n            categories[field.categoryid].fields.push(field);\n        });\n\n        return Object.keys(categories).map((index) => categories[Number(index)]);\n    }\n\n    /**\n     * Get disabled features from a site public config.\n     *\n     * @param config Site public config.\n     * @returns Disabled features.\n     */\n    getDisabledFeatures(config?: CoreSitePublicConfigResponse): string {\n        const disabledFeatures = config?.tool_mobile_disabledfeatures;\n        if (!disabledFeatures) {\n            return '';\n        }\n\n        return CoreTextUtils.treatDisabledFeatures(disabledFeatures);\n    }\n\n    /**\n     * Builds an object with error messages for some common errors.\n     * Please notice that this function doesn't support all possible error types.\n     *\n     * @param requiredMsg Code of the string for required error.\n     * @param emailMsg Code of the string for invalid email error.\n     * @param patternMsg Code of the string for pattern not match error.\n     * @param urlMsg Code of the string for invalid url error.\n     * @param minlengthMsg Code of the string for \"too short\" error.\n     * @param maxlengthMsg Code of the string for \"too long\" error.\n     * @param minMsg Code of the string for min value error.\n     * @param maxMsg Code of the string for max value error.\n     * @returns Object with the errors.\n     */\n    getErrorMessages(\n        requiredMsg?: string,\n        emailMsg?: string,\n        patternMsg?: string,\n        urlMsg?: string,\n        minlengthMsg?: string,\n        maxlengthMsg?: string,\n        minMsg?: string,\n        maxMsg?: string,\n    ): Record<string, string> {\n        const errors: Record<string, string> = {};\n\n        if (requiredMsg) {\n            errors.required = errors.requiredTrue = Translate.instant(requiredMsg);\n        }\n        if (emailMsg) {\n            errors.email = Translate.instant(emailMsg);\n        }\n        if (patternMsg) {\n            errors.pattern = Translate.instant(patternMsg);\n        }\n        if (urlMsg) {\n            errors.url = Translate.instant(urlMsg);\n        }\n        if (minlengthMsg) {\n            errors.minlength = Translate.instant(minlengthMsg);\n        }\n        if (maxlengthMsg) {\n            errors.maxlength = Translate.instant(maxlengthMsg);\n        }\n        if (minMsg) {\n            errors.min = Translate.instant(minMsg);\n        }\n        if (maxMsg) {\n            errors.max = Translate.instant(maxMsg);\n        }\n\n        return errors;\n    }\n\n    /**\n     * Get logo URL from a site public config.\n     *\n     * @param config Site public config.\n     * @returns Logo URL.\n     */\n    getLogoUrl(config: CoreSitePublicConfigResponse): string | undefined {\n        return !CoreConstants.CONFIG.forceLoginLogo && config ? (config.logourl || config.compactlogourl) : undefined;\n    }\n\n    /**\n     * Returns the logout label of a site.\n     *\n     * @param site Site. If not defined, use current site.\n     * @returns The string key.\n     */\n    getLogoutLabel(site?: CoreSite): string {\n        site = site || CoreSites.getCurrentSite();\n        const config = site?.getStoredConfig();\n\n        return 'core.mainmenu.' + (config && config.tool_mobile_forcelogout == '1' ? 'logout' : 'switchaccount');\n    }\n\n    /**\n     * Get the OAuth ID of some URL params (if it has an OAuth ID).\n     *\n     * @param params Params.\n     * @returns OAuth ID.\n     */\n    getOAuthIdFromParams(params?: CoreUrlParams): number | undefined {\n        return params && params.oauthsso !== undefined ? Number(params.oauthsso) : undefined;\n    }\n\n    /**\n     * Get the site policy.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     * @returns Promise resolved with the site policy.\n     */\n    async getSitePolicy(siteId?: string): Promise<string> {\n        const site = await CoreSites.getSite(siteId);\n\n        let sitePolicy: string | undefined;\n\n        try {\n            // Try to get the latest config, maybe the site policy was just added or has changed.\n            sitePolicy = await site.getConfig('sitepolicy', true);\n        } catch (error) {\n            // Cannot get config, try to get the site policy using auth_email_get_signup_settings.\n            const settings = <AuthEmailSignupSettings> await CoreWS.callAjax(\n                'auth_email_get_signup_settings',\n                {},\n                { siteUrl: site.getURL() },\n            );\n\n            sitePolicy = settings.sitepolicy;\n        }\n\n        if (!sitePolicy) {\n            throw new CoreError('Cannot retrieve site policy');\n        }\n\n        return sitePolicy;\n    }\n\n    /**\n     * Get fixed site or sites.\n     *\n     * @returns Fixed site or list of fixed sites.\n     * @deprecated since 4.2.0. Use CoreConstants.CONFIG.sites or getAvailableSites() instead.\n     */\n    getFixedSites(): string | CoreLoginSiteInfo[] {\n        const notStagingSites = CoreConstants.CONFIG.sites.filter(site => !site.staging);\n\n        return notStagingSites.length === 1 ? notStagingSites[0].url : notStagingSites;\n    }\n\n    /**\n     * Get Available sites (includes staging sites if are enabled).\n     *\n     * @returns Available sites.\n     */\n    async getAvailableSites(): Promise<CoreLoginSiteInfo[]> {\n        const hasEnabledStagingSites = await CoreSettingsHelper.hasEnabledStagingSites();\n\n        return hasEnabledStagingSites ? CoreConstants.CONFIG.sites : CoreConstants.CONFIG.sites.filter(site => !site.staging);\n    }\n\n    /**\n     * Get the valid identity providers from a site config.\n     *\n     * @param siteConfig Site's public config.\n     * @param disabledFeatures List of disabled features already treated. If not provided it will be calculated.\n     * @returns Valid identity providers.\n     */\n    getValidIdentityProviders(siteConfig?: CoreSitePublicConfigResponse, disabledFeatures?: string): CoreSiteIdentityProvider[] {\n        if (!siteConfig) {\n            return [];\n        }\n        if (this.isFeatureDisabled('NoDelegate_IdentityProviders', siteConfig, disabledFeatures)) {\n            // Identity providers are disabled, return an empty list.\n            return [];\n        }\n\n        const validProviders: CoreSiteIdentityProvider[] = [];\n        const httpUrl = CorePath.concatenatePaths(siteConfig.wwwroot, 'auth/oauth2/');\n        const httpsUrl = CorePath.concatenatePaths(siteConfig.httpswwwroot, 'auth/oauth2/');\n\n        if (siteConfig.identityproviders && siteConfig.identityproviders.length) {\n            siteConfig.identityproviders.forEach((provider) => {\n                const urlParams = CoreUrlUtils.extractUrlParams(provider.url);\n\n                if (provider.url && (provider.url.indexOf(httpsUrl) != -1 || provider.url.indexOf(httpUrl) != -1) &&\n                        !this.isFeatureDisabled('NoDelegate_IdentityProvider_' + urlParams.id, siteConfig, disabledFeatures)) {\n                    validProviders.push(provider);\n                }\n            });\n        }\n\n        return validProviders;\n    }\n\n    /**\n     * Go to the page to add a new site.\n     * If a fixed URL is configured, go to credentials instead.\n     *\n     * @param setRoot True to set the new page as root, false to add it to the stack.\n     * @param showKeyboard Whether to show keyboard in the new page. Only if no fixed URL set.\n     * @returns Promise resolved when done.\n     */\n    async goToAddSite(setRoot = false, showKeyboard = false): Promise<void> {\n        let path = '/login/sites';\n        let params: Params = { openAddSite: true , showKeyboard };\n\n        if (CoreSites.isLoggedIn()) {\n            const willReload = await CoreSites.logoutForRedirect(CoreConstants.NO_SITE_ID, {\n                redirectPath: path,\n                redirectOptions: { params },\n            });\n\n            if (willReload) {\n                return;\n            }\n        } else {\n            [path, params] = await this.getAddSiteRouteInfo(showKeyboard);\n        }\n\n        await CoreNavigator.navigate(path, { params, reset: setRoot });\n    }\n\n    /**\n     * Get path and params to visit the route to add site.\n     *\n     * @param showKeyboard Whether to show keyboard in the new page. Only if no fixed URL set.\n     * @returns Path and params.\n     */\n    async getAddSiteRouteInfo(showKeyboard?: boolean): Promise<[string, Params]> {\n        const sites = await this.getAvailableSites();\n\n        if (sites.length === 1) {\n            // Fixed URL is set, go to credentials page.\n            return ['/login/credentials', { siteUrl: sites[0].url }];\n        }\n\n        return ['/login/site', { showKeyboard }];\n    }\n\n    /**\n     * Open a page that doesn't belong to any site.\n     *\n     * @param page Page to open.\n     * @param params Params of the page.\n     * @returns Promise resolved when done.\n     * @deprecated since 3.9.5. Use CoreNavigator.navigateToLoginCredentials instead.\n     */\n    async goToNoSitePage(page: string, params?: Params): Promise<void> {\n        await CoreNavigator.navigateToLoginCredentials(params);\n    }\n\n    /**\n     * Go to the initial page of a site depending on 'userhomepage' setting.\n     *\n     * @param navCtrlUnused Deprecated param.\n     * @param page Name of the page to load after loading the main page.\n     * @param params Params to pass to the page.\n     * @param options Navigation options.\n     * @param url URL to open once the main menu is loaded.\n     * @returns Promise resolved when done.\n     * @deprecated since 3.9.5. Use CoreNavigator.navigateToSiteHome or CoreNavigator.navigateToSitePath instead.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async goToSiteInitialPage(navCtrlUnused?: unknown, page?: string, params?: any, options?: any, url?: string): Promise<void> {\n        await CoreNavigator.navigateToSiteHome({\n            ...options,\n            params: <CoreRedirectPayload> {\n                redirectPath: page,\n                redirectOptions: { params },\n                urlToOpen: url,\n            },\n        });\n    }\n\n    /**\n     * Convenient helper to handle authentication in the app using a token received by SSO login. If it's a new account,\n     * the site is stored and the user is authenticated. If the account already exists, update its token.\n     *\n     * @param siteUrl Site's URL.\n     * @param token User's token.\n     * @param privateToken User's private token.\n     * @param oauthId OAuth ID. Only if the authentication was using an OAuth method.\n     * @returns Promise resolved when the user is authenticated with the token.\n     */\n    handleSSOLoginAuthentication(siteUrl: string, token: string, privateToken?: string, oauthId?: number): Promise<string> {\n        // Always create a new site to prevent overriding data if another user credentials were introduced.\n        return CoreSites.newSite(siteUrl, token, privateToken, true, oauthId);\n    }\n\n    /**\n     * Check if the app is configured to use several fixed URLs.\n     *\n     * @returns Whether there are several fixed URLs.\n     * @deprecated 4.2.0 Use CoreConstants.CONFIG.sites.length > 1 instead.\n     */\n    async hasSeveralFixedSites(): Promise<boolean> {\n        const sites = await this.getAvailableSites();\n\n        return sites.length > 1;\n    }\n\n    /**\n     * Given a site public config, check if email signup is disabled.\n     *\n     * @param config Site public config.\n     * @param disabledFeatures List of disabled features already treated. If not provided it will be calculated.\n     * @returns Whether email signup is disabled.\n     */\n    isEmailSignupDisabled(config?: CoreSitePublicConfigResponse, disabledFeatures?: string): boolean {\n        return this.isFeatureDisabled('CoreLoginEmailSignup', config, disabledFeatures);\n    }\n\n    /**\n     * Given a site public config, check if a certian feature is disabled.\n     *\n     * @param feature Feature to check.\n     * @param config Site public config.\n     * @param disabledFeatures List of disabled features already treated. If not provided it will be calculated.\n     * @returns Whether email signup is disabled.\n     */\n    isFeatureDisabled(feature: string, config?: CoreSitePublicConfigResponse, disabledFeatures?: string): boolean {\n        if (disabledFeatures === undefined) {\n            disabledFeatures = this.getDisabledFeatures(config);\n        }\n\n        const regEx = new RegExp('(,|^)' + feature + '(,|$)', 'g');\n\n        return !!disabledFeatures.match(regEx);\n    }\n\n    /**\n     * Check if the app is configured to use a fixed URL (only 1).\n     *\n     * @returns Whether there is 1 fixed URL.\n     * @deprecated 4.2.0 Use isSingleFixedSite instead.\n     */\n    isFixedUrlSet(): boolean {\n        return CoreConstants.CONFIG.sites.filter(site => !site.staging).length === 1;\n    }\n\n    /**\n     * Check if the app is configured to use a fixed URL (only 1).\n     *\n     * @returns Whether there is 1 fixed URL.\n     */\n    async isSingleFixedSite(): Promise<boolean> {\n        const sites = await this.getAvailableSites();\n\n        return sites.length === 1;\n    }\n\n    /**\n     * Given a site public config, check if forgotten password is disabled.\n     *\n     * @param config Site public config.\n     * @param disabledFeatures List of disabled features already treated. If not provided it will be calculated.\n     * @returns Whether it's disabled.\n     */\n    isForgottenPasswordDisabled(config?: CoreSitePublicConfigResponse, disabledFeatures?: string): boolean {\n        return this.isFeatureDisabled('NoDelegate_ForgottenPassword', config, disabledFeatures);\n    }\n\n    /**\n     * Check if current site is logged out, triggering session expired event if it is.\n     *\n     * @param redirectData Data of the path/url to open once authenticated if logged out. If not defined, site initial page.\n     * @returns True if user is logged out, false otherwise.\n     */\n    isSiteLoggedOut(redirectData?: CoreRedirectPayload): boolean {\n        const site = CoreSites.getCurrentSite();\n        if (!site) {\n            return false;\n        }\n\n        if (site.isLoggedOut()) {\n            CoreEvents.trigger(CoreEvents.SESSION_EXPIRED, redirectData || {}, site.getId());\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if a site URL is \"allowed\". In case the app has fixed sites, only those will be allowed to connect to.\n     *\n     * @param siteUrl Site URL to check.\n     * @param checkSiteFinder Whether to check site finder if needed. Defaults to true.\n     * @returns Promise resolved with boolean: whether is one of the fixed sites.\n     */\n    async isSiteUrlAllowed(siteUrl: string, checkSiteFinder = true): Promise<boolean> {\n        const sites = await this.getAvailableSites();\n\n        if (sites.length) {\n            return sites.some((site) => CoreUrl.sameDomainAndPath(siteUrl, site.url));\n        } else if (CoreConstants.CONFIG.multisitesdisplay == 'sitefinder' && CoreConstants.CONFIG.onlyallowlistedsites &&\n                checkSiteFinder) {\n            // Call the sites finder to validate the site.\n            const result = await CoreSites.findSites(siteUrl.replace(/^https?:\\/\\/|\\.\\w{2,3}\\/?$/g, ''));\n\n            return result && result.some((site) => CoreUrl.sameDomainAndPath(siteUrl, site.url));\n        } else {\n            // No fixed sites or it uses a non-restrictive sites finder. Allow connecting.\n            return true;\n        }\n    }\n\n    /**\n     * Check if SSO login should use an embedded browser.\n     *\n     * @param code Code to check.\n     * @returns True if embedded browser, false othwerise.\n     */\n    isSSOEmbeddedBrowser(code: number): boolean {\n        return code == CoreConstants.LOGIN_SSO_INAPP_CODE;\n    }\n\n    /**\n     * Check if SSO login is needed based on code returned by the WS.\n     *\n     * @param code Code to check.\n     * @returns True if SSO login is needed, false othwerise.\n     */\n    isSSOLoginNeeded(code: number): boolean {\n        return code == CoreConstants.LOGIN_SSO_CODE || code == CoreConstants.LOGIN_SSO_INAPP_CODE;\n    }\n\n    /**\n     * Load a certain page in the main menu page.\n     *\n     * @param page Name of the page to load.\n     * @param params Params to pass to the page.\n     * @deprecated since 3.9.5. Use CoreNavigator.navigateToSitepath instead.\n     */\n    loadPageInMainMenu(page: string, params?: Params): void {\n        CoreNavigator.navigateToSitePath(page, { params });\n    }\n\n    /**\n     * Open a browser to perform OAuth login (Google, Facebook, Microsoft).\n     *\n     * @param siteUrl URL of the site where the login will be performed.\n     * @param provider The identity provider.\n     * @param launchUrl The URL to open for SSO. If not defined, tool/mobile launch URL will be used.\n     * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n     * @returns True if success, false if error.\n     */\n    openBrowserForOAuthLogin(\n        siteUrl: string,\n        provider: CoreSiteIdentityProvider,\n        launchUrl?: string,\n        redirectData?: CoreRedirectPayload,\n    ): boolean {\n        launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';\n        if (!provider || !provider.url) {\n            return false;\n        }\n\n        const params = CoreUrlUtils.extractUrlParams(provider.url);\n\n        if (!params.id) {\n            return false;\n        }\n\n        const loginUrl = this.prepareForSSOLogin(siteUrl, undefined, launchUrl, redirectData, {\n            oauthsso: params.id,\n        });\n\n        // Always open it in browser because the user might have the session stored in there.\n        CoreUtils.openInBrowser(loginUrl, { showBrowserWarning: false });\n        CoreApp.closeApp();\n\n        return true;\n    }\n\n    /**\n     * Open a browser to perform SSO login.\n     *\n     * @param siteUrl URL of the site where the SSO login will be performed.\n     * @param typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.\n     * @param service The service to use. If not defined, core service will be used.\n     * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n     * @param redirectData Data of the path/url to open once authenticated. If not defined, site initial page.\n     */\n    openBrowserForSSOLogin(\n        siteUrl: string,\n        typeOfLogin: number,\n        service?: string,\n        launchUrl?: string,\n        redirectData?: CoreRedirectPayload,\n    ): void {\n        const loginUrl = this.prepareForSSOLogin(siteUrl, service, launchUrl, redirectData);\n\n        if (this.isSSOEmbeddedBrowser(typeOfLogin)) {\n            CoreUtils.openInApp(loginUrl, {\n                clearsessioncache: 'yes', // Clear the session cache to allow for multiple logins.\n                closebuttoncaption: Translate.instant('core.login.cancel'),\n            });\n        } else {\n            CoreUtils.openInBrowser(loginUrl, { showBrowserWarning: false });\n            CoreApp.closeApp();\n        }\n    }\n\n    /**\n     * Convenient helper to open change password page.\n     *\n     * @param siteUrl Site URL to construct change password URL.\n     * @param error Error message.\n     * @returns Promise resolved when done.\n     */\n    async openChangePassword(siteUrl: string, error: string): Promise<void> {\n        const alert = await CoreDomUtils.showAlert(Translate.instant('core.notice'), error, undefined, 3000);\n\n        await alert.onDidDismiss();\n\n        CoreUtils.openInApp(siteUrl + '/login/change_password.php');\n    }\n\n    /**\n     * Open forgotten password in inappbrowser.\n     *\n     * @param siteUrl URL of the site.\n     */\n    openForgottenPassword(siteUrl: string): void {\n        CoreUtils.openInApp(siteUrl + '/login/forgot_password.php');\n    }\n\n    /**\n     * Function to open in app browser to change password or complete user profile.\n     *\n     * @param siteId The site ID.\n     * @param path The relative path of the URL to open.\n     * @param alertMessage The key of the message to display before opening the in app browser.\n     * @param invalidateCache Whether to invalidate site's cache (e.g. when the user is forced to change password).\n     * @returns Promise resolved when done.\n     */\n    async openInAppForEdit(siteId: string, path: string, alertMessage?: string, invalidateCache?: boolean): Promise<void> {\n        if (!siteId || siteId !== CoreSites.getCurrentSiteId()) {\n            // Site that triggered the event is not current site, nothing to do.\n            return;\n        }\n\n        const currentSite = CoreSites.getCurrentSite();\n        const siteUrl = currentSite?.getURL();\n\n        if (!currentSite || !siteUrl) {\n            return;\n        }\n\n        if (!this.isOpenEditAlertShown && !this.waitingForBrowser) {\n            this.isOpenEditAlertShown = true;\n\n            if (invalidateCache) {\n                currentSite.invalidateWsCache();\n            }\n\n            // Open change password.\n            if (alertMessage) {\n                alertMessage = Translate.instant(alertMessage) + '<br>' +\n                    Translate.instant('core.redirectingtosite');\n            }\n\n            try {\n                await currentSite.openInAppWithAutoLogin(siteUrl + path, undefined, alertMessage);\n            } finally {\n                this.isOpenEditAlertShown = false;\n            }\n\n            await this.waitForBrowser();\n\n            CoreEvents.trigger(CoreEvents.COMPLETE_REQUIRED_PROFILE_DATA_FINISHED, {\n                path,\n            }, siteId);\n        }\n    }\n\n    /**\n     * Function that should be called when password change is forced. Reserved for core use.\n     *\n     * @param siteId The site ID. Undefined for current site.\n     */\n    async passwordChangeForced(siteId?: string): Promise<void> {\n        const currentSite = CoreSites.getCurrentSite();\n        siteId = siteId ?? currentSite?.getId();\n\n        if (!currentSite || siteId !== currentSite.getId()) {\n            return; // Site that triggered the event is not current site.\n        }\n\n        // If current page is already change password, stop.\n        if (CoreNavigator.isCurrent('/login/changepassword')) {\n            return;\n        }\n\n        await CoreNavigator.navigate('/login/changepassword', { params: { siteId }, reset: true });\n    }\n\n    /**\n     * Prepare the app to perform SSO login.\n     *\n     * @param siteUrl URL of the site where the SSO login will be performed.\n     * @param service The service to use. If not defined, core service will be used.\n     * @param launchUrl The URL to open for SSO. If not defined, default tool mobile launch URL will be used.\n     * @param redirectData Redirect dataof the page to go once authenticated. If not defined, site initial page.\n     * @param urlParams Other params to add to the URL.\n     * @returns Login Url.\n     */\n    prepareForSSOLogin(\n        siteUrl: string,\n        service?: string,\n        launchUrl?: string,\n        redirectData: CoreRedirectPayload = {},\n        urlParams?: CoreUrlParams,\n    ): string {\n\n        service = service || CoreConstants.CONFIG.wsservice;\n        launchUrl = launchUrl || siteUrl + '/admin/tool/mobile/launch.php';\n\n        const passport = Math.random() * 1000;\n        let loginUrl = launchUrl + '?service=' + service;\n\n        loginUrl += '&passport=' + passport;\n        loginUrl += '&urlscheme=' + CoreConstants.CONFIG.customurlscheme;\n\n        if (urlParams) {\n            loginUrl = CoreUrlUtils.addParamsToUrl(loginUrl, urlParams);\n        }\n\n        // Store the siteurl and passport in CoreConfigProvider for persistence.\n        // We are \"configuring\" the app to wait for an SSO. CoreConfigProvider shouldn't be used as a temporary storage.\n        CoreConfig.set(CoreConstants.LOGIN_LAUNCH_DATA, JSON.stringify(<StoredLoginLaunchData> {\n            siteUrl: siteUrl,\n            passport: passport,\n            ...redirectData,\n            ssoUrlParams: urlParams || {},\n        }));\n\n        return loginUrl;\n    }\n\n    /**\n     * Redirect to a new page, setting it as the root page and loading the right site if needed.\n     *\n     * @param page Name of the page to load.\n     * @param params Params to pass to the page.\n     * @param siteId Site to load. If not defined, current site.\n     * @returns Promise resolved when done.\n     * @deprecated since 3.9.5. Use CoreNavigator.navigateToSitePath instead.\n     */\n    async redirect(page: string, params?: Params, siteId?: string): Promise<void> {\n        await CoreNavigator.navigateToSitePath(page, { params, siteId });\n    }\n\n    /**\n     * Request a password reset.\n     *\n     * @param siteUrl URL of the site.\n     * @param username Username to search.\n     * @param email Email to search.\n     * @returns Promise resolved when done.\n     */\n    requestPasswordReset(siteUrl: string, username?: string, email?: string): Promise<CoreLoginRequestPasswordResetResult> {\n        const params: Record<string, string> = {};\n\n        if (username) {\n            params.username = username;\n        }\n\n        if (email) {\n            params.email = email;\n        }\n\n        return CoreWS.callAjax('core_auth_request_password_reset', params, { siteUrl });\n    }\n\n    /**\n     * Function that should be called when the session expires. Reserved for core use.\n     *\n     * @param data Data received by the SESSION_EXPIRED event.\n     * @returns Promise resolved when done.\n     */\n    async sessionExpired(data: CoreEventSessionExpiredData & CoreEventSiteData): Promise<void> {\n        const siteId = data?.siteId;\n        const currentSite = CoreSites.getCurrentSite();\n        const siteUrl = currentSite?.getURL();\n\n        if (!currentSite || !siteUrl) {\n            return;\n        }\n\n        if (siteId && siteId !== currentSite.getId()) {\n            return; // Site that triggered the event is not current site.\n        }\n\n        if (this.sessionExpiredCheckingSite[siteId || '']) {\n            return; // Operation pending.\n        }\n\n        this.sessionExpiredCheckingSite[siteId || ''] = true;\n        const redirectData: CoreRedirectPayload = {\n            redirectPath: data.redirectPath,\n            redirectOptions: data.redirectOptions,\n            urlToOpen: data.urlToOpen,\n        };\n\n        try {\n            // Check authentication method.\n            const result = await CoreSites.checkSite(siteUrl);\n\n            if (this.isSSOLoginNeeded(result.code)) {\n                // SSO. User needs to authenticate in a browser. Check if we need to display a message.\n                if (!CoreApp.isSSOAuthenticationOngoing() && !this.waitingForBrowser) {\n                    try {\n                        if (this.shouldShowSSOConfirm(result.code)) {\n                            await CoreDomUtils.showConfirm(Translate.instant('core.login.' +\n                                (currentSite.isLoggedOut() ? 'loggedoutssodescription' : 'reconnectssodescription')));\n                        }\n\n                        this.waitForBrowser();\n\n                        this.openBrowserForSSOLogin(\n                            result.siteUrl,\n                            result.code,\n                            result.service,\n                            result.config?.launchurl,\n                            redirectData,\n                        );\n                    } catch (error) {\n                        // User cancelled, logout him.\n                        CoreSites.logout();\n                    }\n                }\n            } else {\n                if (currentSite.isOAuth()) {\n                    // User authenticated using an OAuth method. Check if it's still valid.\n                    const identityProviders = this.getValidIdentityProviders(result.config);\n                    const providerToUse = identityProviders.find((provider) => {\n                        const params = CoreUrlUtils.extractUrlParams(provider.url);\n\n                        return Number(params.id) == currentSite.getOAuthId();\n                    });\n\n                    if (providerToUse) {\n                        if (!CoreApp.isSSOAuthenticationOngoing() && !this.waitingForBrowser) {\n                            // Open browser to perform the OAuth.\n                            const confirmMessage = Translate.instant('core.login.' +\n                                    (currentSite.isLoggedOut() ? 'loggedoutssodescription' : 'reconnectssodescription'));\n\n                            try {\n                                await CoreDomUtils.showConfirm(confirmMessage);\n\n                                this.waitForBrowser();\n                                CoreSites.unsetCurrentSite(); // Unset current site to make authentication work fine.\n\n                                this.openBrowserForOAuthLogin(\n                                    siteUrl,\n                                    providerToUse,\n                                    result.config?.launchurl,\n                                    redirectData,\n                                );\n                            } catch (error) {\n                                // User cancelled, logout him.\n                                CoreSites.logout();\n                            }\n                        }\n\n                        return;\n                    }\n                }\n\n                const info = currentSite.getInfo();\n                if (info !== undefined && info.username !== undefined) {\n                    // If current page is already reconnect, stop.\n                    if (CoreNavigator.isCurrent('/login/reconnect')) {\n                        return;\n                    }\n\n                    await CoreUtils.ignoreErrors(CoreNavigator.navigate('/login/reconnect', {\n                        params: {\n                            siteId,\n                            ...redirectData,\n                        },\n                        reset: true,\n                    }));\n                }\n            }\n        } catch (error) {\n            // Error checking site.\n            if (currentSite.isLoggedOut()) {\n                // Site is logged out, show error and logout the user.\n                CoreDomUtils.showErrorModalDefault(error, 'core.networkerrormsg', true);\n                CoreSites.logout();\n            }\n        } finally {\n            this.sessionExpiredCheckingSite[siteId || ''] = false;\n        }\n    }\n\n    /**\n     * Check if a confirm should be shown to open a SSO authentication.\n     *\n     * @param typeOfLogin CoreConstants.LOGIN_SSO_CODE or CoreConstants.LOGIN_SSO_INAPP_CODE.\n     * @returns True if confirm modal should be shown, false otherwise.\n     */\n    shouldShowSSOConfirm(typeOfLogin: number): boolean {\n        return !this.isSSOEmbeddedBrowser(typeOfLogin) &&\n            (!CoreConstants.CONFIG.skipssoconfirmation || String(CoreConstants.CONFIG.skipssoconfirmation) === 'false');\n    }\n\n    /**\n     * Show a modal warning that the credentials introduced were not correct.\n     */\n    protected showInvalidLoginModal(error: CoreLoginError): void {\n        CoreDomUtils.showErrorModal(error.errorDetails ?? error.message);\n    }\n\n    /**\n     * Show a modal warning the user that he should use the Workplace app.\n     *\n     * @param message The warning message.\n     */\n    protected showWorkplaceNoticeModal(message: string): void {\n        const link = CoreApp.getAppStoreUrl({ android: 'com.moodle.workplace', ios: 'id1470929705' });\n\n        CoreDomUtils.showDownloadAppNoticeModal(message, link);\n    }\n\n    /**\n     * Show a modal warning the user that he should use the current Moodle app.\n     *\n     * @param message The warning message.\n     */\n    protected showMoodleAppNoticeModal(message: string): void {\n        const storesConfig: CoreStoreConfig = CoreConstants.CONFIG.appstores;\n        storesConfig.mobile = 'https://download.moodle.org/mobile/';\n        storesConfig.default = 'https://download.moodle.org/mobile/';\n\n        const link = CoreApp.getAppStoreUrl(storesConfig);\n\n        CoreDomUtils.showDownloadAppNoticeModal(message, link);\n    }\n\n    /**\n     * Show a modal to inform the user that a confirmation email was sent, and a button to resend the email on 3.6+ sites.\n     *\n     * @param siteUrl Site URL.\n     * @param email Email of the user. If set displayed in the message.\n     * @param username Username. If not set the button to resend email will not be shown.\n     * @param password User password. If not set the button to resend email will not be shown.\n     */\n    protected async showNotConfirmedModal(siteUrl: string, email?: string, username?: string, password?: string): Promise<void> {\n        const title = Translate.instant('core.login.mustconfirm');\n        let message: string;\n        let canResend = false;\n        if (email) {\n            message = Translate.instant('core.login.emailconfirmsent', { $a: email });\n        } else {\n            message = Translate.instant('core.login.emailconfirmsentnoemail');\n        }\n\n        // Check whether we need to display the resend button or not.\n        if (username && password) {\n            canResend = await this.canResendEmail(siteUrl);\n        }\n\n        if (!canResend) {\n            // Just display an informative alert.\n            await CoreDomUtils.showAlert(title, message);\n\n            return;\n        }\n\n        const okText = Translate.instant('core.login.resendemail');\n        const cancelText = Translate.instant('core.close');\n\n        try {\n            // Ask the user if he wants to resend the email.\n            await CoreDomUtils.showConfirm(message, title, okText, cancelText);\n\n            // Call the WS to resend the confirmation email.\n            const modal = await CoreDomUtils.showModalLoading('core.sending', true);\n            const data = { username, password };\n            const preSets = { siteUrl };\n\n            try {\n                const result = <ResendConfirmationEmailResult> await CoreWS.callAjax(\n                    'core_auth_resend_confirmation_email',\n                    data,\n                    preSets,\n                );\n\n                if (!result.status) {\n                    if (result.warnings?.length) {\n                        throw new CoreWSError(result.warnings[0]);\n                    }\n\n                    throw new CoreError('Error sending confirmation email');\n                }\n\n                const message = Translate.instant('core.login.emailconfirmsentsuccess');\n                CoreDomUtils.showAlert(Translate.instant('core.success'), message);\n            } finally {\n                modal.dismiss();\n            }\n        } catch (error) {\n            CoreDomUtils.showErrorModal(error);\n        }\n    }\n\n    /**\n     * Check if confirmation email an be resent.\n     *\n     * @param siteUrl Site URL to check.\n     * @returns Promise.\n     */\n    protected async canResendEmail(siteUrl: string): Promise<boolean> {\n        const modal = await CoreDomUtils.showModalLoading();\n\n        // We don't have site info before login, the only way to check if the WS is available is by calling it.\n        try {\n            // This call will always fail because we aren't sending parameters.\n            await CoreWS.callAjax('core_auth_resend_confirmation_email', {}, { siteUrl });\n\n            return true; // We should never reach here.\n        } catch (error) {\n            // If the WS responds with an invalid parameter error it means the WS is avaiable.\n            return error?.errorcode === 'invalidparameter';\n        } finally {\n            modal.dismiss();\n        }\n    }\n\n    /**\n     * Function called when site policy is not agreed. Reserved for core use.\n     *\n     * @param siteId Site ID. If not defined, current site.\n     */\n    sitePolicyNotAgreed(siteId?: string): void {\n        siteId = siteId || CoreSites.getCurrentSiteId();\n        if (!siteId || siteId != CoreSites.getCurrentSiteId()) {\n            // Only current site allowed.\n            return;\n        }\n\n        // If current page is already site policy, stop.\n        if (CoreNavigator.isCurrent('/login/sitepolicy')) {\n            return;\n        }\n\n        CoreNavigator.navigate('/login/sitepolicy', { params: { siteId }, reset: true });\n    }\n\n    /**\n     * Convenient helper to handle get User Token error. It redirects to change password page if forcepassword is set.\n     *\n     * @param siteUrl Site URL to construct change password URL.\n     * @param error Error object containing errorcode and error message.\n     * @param username Username.\n     * @param password User password.\n     */\n    treatUserTokenError(siteUrl: string, error: CoreWSError, username?: string, password?: string): void {\n        switch (error.errorcode) {\n            case 'forcepasswordchangenotice':\n                this.openChangePassword(siteUrl, CoreTextUtils.getErrorMessageFromError(error) ?? '');\n                break;\n            case 'usernotconfirmed':\n                this.showNotConfirmedModal(siteUrl, undefined, username, password);\n                break;\n            case 'connecttomoodleapp':\n                this.showMoodleAppNoticeModal(CoreTextUtils.getErrorMessageFromError(error) ?? '');\n                break;\n            case 'connecttoworkplaceapp':\n                this.showWorkplaceNoticeModal(CoreTextUtils.getErrorMessageFromError(error) ?? '');\n                break;\n            case 'invalidlogin':\n                this.showInvalidLoginModal(error);\n                break;\n            default:\n                CoreDomUtils.showErrorModal(error);\n                break;\n        }\n    }\n\n    /**\n     * Convenient helper to validate a browser SSO login.\n     *\n     * @param url URL received, to be validated.\n     * @returns Promise resolved on success.\n     */\n    async validateBrowserSSOLogin(url: string): Promise<CoreLoginSSOData> {\n        // Split signature:::token\n        const params = url.split(':::');\n\n        const serializedData = await CoreConfig.get<string>(CoreConstants.LOGIN_LAUNCH_DATA);\n\n        const data = <StoredLoginLaunchData | null> CoreTextUtils.parseJSON(serializedData, null);\n        if (data === null) {\n            throw new CoreError('No launch data stored.');\n        }\n\n        const passport = data.passport;\n        let launchSiteURL = data.siteUrl;\n\n        // Reset temporary values.\n        CoreConfig.delete(CoreConstants.LOGIN_LAUNCH_DATA);\n\n        // Validate the signature.\n        // We need to check both http and https.\n        let signature = <string> Md5.hashAsciiStr(launchSiteURL + passport);\n        if (signature != params[0]) {\n            if (launchSiteURL.indexOf('https://') != -1) {\n                launchSiteURL = launchSiteURL.replace('https://', 'http://');\n            } else {\n                launchSiteURL = launchSiteURL.replace('http://', 'https://');\n            }\n            signature = <string> Md5.hashAsciiStr(launchSiteURL + passport);\n        }\n\n        if (signature == params[0]) {\n            this.logger.debug('Signature validated');\n\n            return {\n                siteUrl: launchSiteURL,\n                token: params[1],\n                privateToken: params[2],\n                redirectPath: data.redirectPath,\n                redirectOptions: data.redirectOptions,\n                urlToOpen: data.urlToOpen,\n                ssoUrlParams: data.ssoUrlParams,\n            };\n        } else {\n            this.logger.debug('Invalid signature in the URL request yours: ' + params[0] + ' mine: '\n                + signature + ' for passport ' + passport);\n\n            throw new CoreError(Translate.instant('core.unexpectederror'));\n        }\n    }\n\n    /**\n     * Return whether the app is waiting for browser.\n     *\n     * @returns Whether the app is waiting for browser.\n     */\n    isWaitingForBrowser(): boolean {\n        return !!this.waitingForBrowser;\n    }\n\n    /**\n     * Start waiting when opening a browser/IAB.\n     *\n     * @returns Promise resolved when the app is resumed.\n     */\n    async waitForBrowser(): Promise<void> {\n        if (!this.waitingForBrowser) {\n            this.waitingForBrowser = new CorePromisedValue();\n        }\n\n        await this.waitingForBrowser;\n    }\n\n    /**\n     * Stop waiting for browser.\n     */\n    stopWaitingForBrowser(): void {\n        this.waitingForBrowser?.resolve();\n        this.waitingForBrowser = undefined;\n    }\n\n    /**\n     * Check whether the QR reader should be displayed in site screen.\n     *\n     * @returns Whether the QR reader should be displayed in site screen.\n     */\n    displayQRInSiteScreen(): boolean {\n        return CoreUtils.canScanQR() && (CoreConstants.CONFIG.displayqronsitescreen === undefined ||\n            !!CoreConstants.CONFIG.displayqronsitescreen);\n    }\n\n    /**\n     * Check whether the QR reader should be displayed in credentials screen.\n     *\n     * @param qrCodeType QR Code type from public config, assuming enabled if undefined.\n     * @returns Whether the QR reader should be displayed in credentials screen.\n     */\n    async displayQRInCredentialsScreen(qrCodeType = CoreSiteQRCodeType.QR_CODE_LOGIN): Promise<boolean> {\n        if (!CoreUtils.canScanQR()) {\n            return false;\n        }\n\n        const isSingleFixedSite = await this.isSingleFixedSite();\n\n        if ((CoreConstants.CONFIG.displayqroncredentialscreen === undefined && isSingleFixedSite) ||\n            (CoreConstants.CONFIG.displayqroncredentialscreen !== undefined &&\n                !!CoreConstants.CONFIG.displayqroncredentialscreen)) {\n\n            return qrCodeType == CoreSiteQRCodeType.QR_CODE_LOGIN;\n        }\n\n        return false;\n    }\n\n    /**\n     * Show instructions to scan QR code.\n     *\n     * @returns Promise resolved if the user accepts to scan QR.\n     */\n    async showScanQRInstructions(): Promise<void> {\n        await new Promise<void>((resolve, reject) => {\n            CoreDomUtils.showAlertWithOptions({\n                header: Translate.instant('core.login.faqwhereisqrcode'),\n                message: Translate.instant(\n                    'core.login.faqwhereisqrcodeanswer',\n                    { $image: CoreLoginHelperProvider.FAQ_QRCODE_IMAGE_HTML },\n                ),\n                buttons: [\n                    {\n                        text: Translate.instant('core.cancel'),\n                        role: 'cancel',\n                        handler: () => reject(new CoreCanceledError()),\n                    },\n                    {\n                        text: Translate.instant('core.next'),\n                        handler: () => resolve(),\n                    },\n                ],\n            });\n        });\n    }\n\n    /**\n     * Scan a QR code and tries to authenticate the user using custom URL scheme.\n     *\n     * @returns Promise resolved when done.\n     */\n    async scanQR(): Promise<void> {\n        // Scan for a QR code.\n        const text = await CoreUtils.scanQR();\n\n        if (text && CoreCustomURLSchemes.isCustomURL(text)) {\n            try {\n                await CoreCustomURLSchemes.handleCustomURL(text);\n            } catch (error) {\n                CoreCustomURLSchemes.treatHandleCustomURLError(error);\n            }\n        } else if (text) {\n            // Not a custom URL scheme, check if it's a URL scheme to another app.\n            const scheme = CoreUrlUtils.getUrlProtocol(text);\n\n            if (scheme && scheme != 'http' && scheme != 'https') {\n                CoreDomUtils.showErrorModal(Translate.instant('core.errorurlschemeinvalidscheme', { $a: text }));\n            } else {\n                CoreDomUtils.showErrorModal('core.login.errorqrnoscheme', true);\n            }\n        }\n    }\n\n    /**\n     * Get the accounts list classified per site.\n     *\n     * @param currentSiteId If loggedin, current Site Id.\n     * @returns Promise resolved with account list.\n     */\n    async getAccountsList(currentSiteId?: string): Promise<CoreAccountsList> {\n        const sites = await CoreUtils.ignoreErrors(CoreSites.getSortedSites(), [] as CoreSiteBasicInfo[]);\n\n        const accountsList: CoreAccountsList = {\n            sameSite: [],\n            otherSites: [],\n            count: sites.length,\n        };\n\n        let siteUrl = '';\n\n        if (currentSiteId) {\n            const index = sites.findIndex((site) => site.id == currentSiteId);\n\n            accountsList.currentSite = sites.splice(index, 1)[0];\n            siteUrl = accountsList.currentSite.siteUrlWithoutProtocol;\n        }\n\n        const otherSites: Record<string, CoreSiteBasicInfo[]> = {};\n\n        // Add site counter and classify sites.\n        await Promise.all(sites.map(async (site) => {\n            site.badge = await CoreUtils.ignoreErrors(CorePushNotifications.getSiteCounter(site.id)) || 0;\n\n            if (site.siteUrlWithoutProtocol == siteUrl) {\n                accountsList.sameSite.push(site);\n            } else {\n                if (!otherSites[site.siteUrlWithoutProtocol]) {\n                    otherSites[site.siteUrlWithoutProtocol] = [];\n                }\n\n                otherSites[site.siteUrlWithoutProtocol].push(site);\n            }\n\n            return;\n        }));\n\n        accountsList.otherSites = CoreUtils.objectToArray(otherSites);\n\n        return accountsList;\n    }\n\n    /**\n     * Find and delete a site from the list of sites.\n     *\n     * @param accountsList Account list.\n     * @param site Site to be deleted.\n     * @returns Resolved when done.\n     */\n    async deleteAccountFromList(accountsList: CoreAccountsList, site: CoreSiteBasicInfo): Promise<void> {\n        await CoreSites.deleteSite(site.id);\n\n        const siteUrl = site.siteUrlWithoutProtocol;\n        let index = 0;\n\n        // Found on same site.\n        if (accountsList.sameSite.length > 0 && accountsList.sameSite[0].siteUrlWithoutProtocol == siteUrl) {\n            index = accountsList.sameSite.findIndex((listedSite) => listedSite.id == site.id);\n            if (index >= 0) {\n                accountsList.sameSite.splice(index, 1);\n                accountsList.count--;\n            }\n\n            return;\n        }\n\n        const otherSiteIndex = accountsList.otherSites.findIndex((sites) =>\n            sites.length > 0 && sites[0].siteUrlWithoutProtocol == siteUrl);\n        if (otherSiteIndex < 0) {\n            // Site Url not found.\n            return;\n        }\n\n        index = accountsList.otherSites[otherSiteIndex].findIndex((listedSite) => listedSite.id == site.id);\n        if (index >= 0) {\n            accountsList.otherSites[otherSiteIndex].splice(index, 1);\n            accountsList.count--;\n        }\n\n        if (accountsList.otherSites[otherSiteIndex].length == 0) {\n            accountsList.otherSites.splice(otherSiteIndex, 1);\n        }\n    }\n\n    /**\n     * Get reconnect page route module.\n     *\n     * @returns Reconnect page route module.\n     */\n    async getReconnectRouteModule(): Promise<unknown> {\n        return import('@features/login/login-reconnect-lazy.module').then(m => m.CoreLoginReconnectLazyModule);\n    }\n\n    /**\n     * Get credentials page route module.\n     *\n     * @returns Credentials page route module.\n     */\n    async getCredentialsRouteModule(): Promise<unknown> {\n        return import('@features/login/login-credentials-lazy.module').then(m => m.CoreLoginCredentialsLazyModule);\n    }\n\n    /**\n     * Retrieve login methods.\n     *\n     * @returns Login methods found.\n     */\n    async getLoginMethods(): Promise<CoreLoginMethod[]> {\n        return [];\n    }\n\n    /**\n     * Retrieve default login method.\n     *\n     * @returns Default login method.\n     */\n    async getDefaultLoginMethod(): Promise<CoreLoginMethod | null> {\n        return null;\n    }\n\n    /**\n     * Record that a password reset has been requested for a given site.\n     *\n     * @param siteUrl Site url.\n     */\n    async passwordResetRequested(siteUrl: string): Promise<void> {\n        const passwordResets = await this.getPasswordResets();\n\n        passwordResets[siteUrl] = Date.now();\n\n        await CoreConfig.set(PASSWORD_RESETS_CONFIG_KEY, JSON.stringify(passwordResets));\n    }\n\n    /**\n     * Find out if a password reset has been requested recently for a given site.\n     *\n     * @param siteUrl Site url.\n     * @returns Whether a password reset has been requested recently.\n     */\n    async wasPasswordResetRequestedRecently(siteUrl: string): Promise<boolean> {\n        const passwordResets = await this.getPasswordResets();\n\n        return siteUrl in passwordResets\n            && passwordResets[siteUrl] > Date.now() - CoreConstants.MILLISECONDS_HOUR;\n    }\n\n    /**\n     * Clean up expired password reset records from the database.\n     */\n    async cleanUpPasswordResets(): Promise<void> {\n        const passwordResets = await this.getPasswordResets();\n        const siteUrls = Object.keys(passwordResets);\n\n        for (const siteUrl of siteUrls) {\n            if (passwordResets[siteUrl] > Date.now() - CoreConstants.MILLISECONDS_HOUR) {\n                continue;\n            }\n\n            delete passwordResets[siteUrl];\n        }\n\n        if (Object.values(passwordResets).length === 0) {\n            await CoreConfig.delete(PASSWORD_RESETS_CONFIG_KEY);\n        } else {\n            await CoreConfig.set(PASSWORD_RESETS_CONFIG_KEY, JSON.stringify(passwordResets));\n        }\n    }\n\n    /**\n     * Build the HTML message to show once login attempts have been exceeded.\n     *\n     * @param canContactSupport Whether contacting support is enabled in the site.\n     * @param canRecoverPassword Whether recovering the password is enabled in the site.\n     * @returns HTML message.\n     */\n    buildExceededAttemptsHTML(canContactSupport: boolean, canRecoverPassword: boolean): SafeHtml | string | null {\n        const safeHTML = (html: string) => DomSanitizer.sanitize(SecurityContext.HTML, html) ?? '';\n        const recoverPasswordHTML = (messageKey: string) => {\n            const placeholder = '%%RECOVER_PASSWORD%%';\n            const message = safeHTML(Translate.instant(messageKey, { recoverPassword: placeholder }));\n            const recoverPassword = safeHTML(Translate.instant('core.login.exceededloginattemptsrecoverpassword'));\n\n            return DomSanitizer.bypassSecurityTrustHtml(\n                message.replace(placeholder, `<a href=\"#\" role=\"button\" style=\"color:inherit\">${recoverPassword}</a>`),\n            );\n        };\n\n        if (canContactSupport && canRecoverPassword) {\n            return recoverPasswordHTML('core.login.exceededloginattempts');\n        }\n\n        if (canContactSupport) {\n            return Translate.instant('core.login.exceededloginattemptswithoutpassword');\n        }\n\n        if (canRecoverPassword) {\n            return recoverPasswordHTML('core.login.exceededloginattemptswithoutsupport');\n        }\n\n        return null;\n    }\n\n    /**\n     * Get a record indexing the last time a password reset was requested for a site.\n     *\n     * @returns Password resets.\n     */\n    protected async getPasswordResets(): Promise<Record<string, number>> {\n        const passwordResetsJson = await CoreConfig.get(PASSWORD_RESETS_CONFIG_KEY, '{}');\n\n        return CoreTextUtils.parseJSON<Record<string, number>>(passwordResetsJson, {});\n    }\n\n}\n\nexport const CoreLoginHelper = makeSingleton(CoreLoginHelperProvider);\n\n/**\n * Accounts list for selecting sites interfaces.\n */\nexport type CoreAccountsList = {\n    currentSite?: CoreSiteBasicInfo; // If logged in, current site info.\n    sameSite: CoreSiteBasicInfo[]; // If logged in, accounts info on the same site.\n    otherSites: CoreSiteBasicInfo[][]; // Other accounts in other sites.\n    count: number; // Number of sites.\n};\n\n/**\n * Data related to a SSO authentication.\n */\nexport type CoreLoginSSOData = CoreRedirectPayload & {\n    siteUrl: string; // The site's URL.\n    token?: string; // User's token.\n    privateToken?: string; // User's private token.\n    ssoUrlParams?: CoreUrlParams; // Other params added to the login url.\n};\n\n/**\n * Result of WS core_user_agree_site_policy.\n */\ntype AgreeSitePolicyResult = {\n    status: boolean; // Status: true only if we set the policyagreed to 1 for the user.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result of WS auth_email_get_signup_settings.\n */\nexport type AuthEmailSignupSettings = {\n    namefields: string[];\n    passwordpolicy?: string; // Password policy.\n    sitepolicy?: string; // Site policy.\n    sitepolicyhandler?: string; // Site policy handler.\n    defaultcity?: string; // Default city.\n    country?: string; // Default country.\n    profilefields?: AuthEmailSignupProfileField[]; // Required profile fields.\n    recaptchapublickey?: string; // Recaptcha public key.\n    recaptchachallengehash?: string; // Recaptcha challenge hash.\n    recaptchachallengeimage?: string; // Recaptcha challenge noscript image.\n    recaptchachallengejs?: string; // Recaptcha challenge js url.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Profile field for signup.\n */\nexport type AuthEmailSignupProfileField = {\n    id?: number; // Profile field id.\n    shortname?: string; // Profile field shortname.\n    name?: string; // Profield field name.\n    datatype?: string; // Profield field datatype.\n    description?: string; // Profield field description.\n    descriptionformat: number; // Description format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    categoryid?: number; // Profield field category id.\n    categoryname?: string; // Profield field category name.\n    sortorder?: number; // Profield field sort order.\n    required?: number; // Profield field required.\n    locked?: number; // Profield field locked.\n    visible?: number; // Profield field visible.\n    forceunique?: number; // Profield field unique.\n    signup?: number; // Profield field in signup form.\n    defaultdata?: string; // Profield field default data.\n    defaultdataformat: number; // Defaultdata format (1 = HTML, 0 = MOODLE, 2 = PLAIN or 4 = MARKDOWN).\n    param1?: string; // Profield field settings.\n    param2?: string; // Profield field settings.\n    param3?: string; // Profield field settings.\n    param4?: string; // Profield field settings.\n    param5?: string; // Profield field settings.\n};\n\n/**\n * Category of profile fields for signup.\n */\nexport type AuthEmailSignupProfileFieldsCategory = {\n    id: number; // Category ID.\n    name: string; // Category name.\n    fields: AuthEmailSignupProfileField[]; // Field in the category.\n};\n\n/**\n * Result of WS core_auth_request_password_reset.\n */\nexport type CoreLoginRequestPasswordResetResult = {\n    status: string; // The returned status of the process\n    notice: string; // Important information for the user about the process.\n    warnings?: CoreWSExternalWarning[];\n};\n\n/**\n * Result of WS core_auth_resend_confirmation_email.\n */\ntype ResendConfirmationEmailResult = {\n    status: boolean; // True if the confirmation email was sent, false otherwise.\n    warnings?: CoreWSExternalWarning[];\n};\n\ntype StoredLoginLaunchData = CoreRedirectPayload & {\n    siteUrl: string;\n    passport: number;\n    ssoUrlParams: CoreUrlParams;\n};\n\nexport type CoreLoginSiteSelectorListMethod =\n    'url'|\n    'sitefinder'|\n    'list'|\n    '';\n\nexport type CoreLoginMethod = {\n    name: string; // Name of the login method.\n    icon: string; // Icon of the provider.\n    action: () => unknown; // Action to execute on button click.\n};\n\nexport type CoreLoginSiteFinderSettings = {\n    displayalias: boolean;\n    displaycity: boolean;\n    displaycountry: boolean;\n    displayimage: boolean;\n    displaysitename: boolean;\n    displayurl: boolean;\n    defaultimageurl?: string;\n};\n"
        }
    ]
}